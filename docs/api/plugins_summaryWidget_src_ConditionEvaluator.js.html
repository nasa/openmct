<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: plugins/summaryWidget/src/ConditionEvaluator.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: plugins/summaryWidget/src/ConditionEvaluator.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>define([], function () {

    /**
     * Responsible for maintaining the possible operations for conditions
     * in this widget, and evaluating the boolean value of conditions passed as
     * input.
     * @constructor
     * @param {Object} subscriptionCache A cache consisting of the latest available
     *                                   data for any telemetry sources in the widget's
     *                                   composition.
     * @param {Object} compositionObjs The current set of composition objects to
     *                                 evaluate for 'any' and 'all' conditions
     */
    function ConditionEvaluator(subscriptionCache, compositionObjs) {
        this.subscriptionCache = subscriptionCache;
        this.compositionObjs = compositionObjs;

        this.testCache = {};
        this.useTestCache = false;

        /**
         * Maps value types to HTML input field types. These
         * type of inputs will be generated by conditions expecting this data type
         */
        this.inputTypes = {
            number: 'number',
            string: 'text'
        };

        /**
         * Functions to validate that the input to an operation is of the type
         * that it expects, in order to prevent unexpected behavior. Will be
         * invoked before the corresponding operation is executed
         */
        this.inputValidators = {
            number: this.validateNumberInput,
            string: this.validateStringInput
        };

        /**
         * A library of operations supported by this rule evaluator. Each operation
         * consists of the following fields:
         * operation: a function with boolean return type to be invoked when this
         *            operation is used. Will be called with an array of inputs
         *            where input [0] is the telemetry value and input [1..n] are
         *            any comparison values
         * text: a human-readable description of this operation to populate selects
         * appliesTo: an array of identifiers for types that operation may be used on
         * inputCount: the number of inputs required to get any necessary comparison
         *             values for the operation
         * getDescription: A function returning a human-readable shorthand description of
         *                this operation to populate the 'description' field in the rule header.
         *                Will be invoked with an array of a condition's comparison values.
         */
        this.operations = {
            equalTo: {
                operation: function (input) {
                    return input[0] === input[1];
                },
                text: 'is equal to',
                appliesTo: ['number'],
                inputCount: 1,
                getDescription: function (values) {
                    return ' == ' + values[0];
                }
            },
            notEqualTo: {
                operation: function (input) {
                    return input[0] !== input[1];
                },
                text: 'is not equal to',
                appliesTo: ['number'],
                inputCount: 1,
                getDescription: function (values) {
                    return ' != ' + values[0];
                }
            },
            greaterThan: {
                operation: function (input) {
                    return input[0] > input[1];
                },
                text: 'is greater than',
                appliesTo: ['number'],
                inputCount: 1,
                getDescription: function (values) {
                    return ' > ' + values[0];
                }
            },
            lessThan: {
                operation: function (input) {
                    return input[0] &lt; input[1];
                },
                text: 'is less than',
                appliesTo: ['number'],
                inputCount: 1,
                getDescription: function (values) {
                    return ' &lt; ' + values[0];
                }
            },
            greaterThanOrEq: {
                operation: function (input) {
                    return input[0] >= input[1];
                },
                text: 'is greater than or equal to',
                appliesTo: ['number'],
                inputCount: 1,
                getDescription: function (values) {
                    return ' >= ' + values[0];
                }
            },
            lessThanOrEq: {
                operation: function (input) {
                    return input[0] &lt;= input[1];
                },
                text: 'is less than or equal to',
                appliesTo: ['number'],
                inputCount: 1,
                getDescription: function (values) {
                    return ' &lt;= ' + values[0];
                }
            },
            between: {
                operation: function (input) {
                    return input[0] > input[1] &amp;&amp; input[0] &lt; input[2];
                },
                text: 'is between',
                appliesTo: ['number'],
                inputCount: 2,
                getDescription: function (values) {
                    return ' between ' + values[0] + ' and ' + values[1];
                }
            },
            notBetween: {
                operation: function (input) {
                    return input[0] &lt; input[1] || input[0] > input[2];
                },
                text: 'is not between',
                appliesTo: ['number'],
                inputCount: 2,
                getDescription: function (values) {
                    return ' not between ' + values[0] + ' and ' + values[1];
                }
            },
            textContains: {
                operation: function (input) {
                    return input[0] &amp;&amp; input[1] &amp;&amp; input[0].includes(input[1]);
                },
                text: 'text contains',
                appliesTo: ['string'],
                inputCount: 1,
                getDescription: function (values) {
                    return ' contains ' + values[0];
                }
            },
            textDoesNotContain: {
                operation: function (input) {
                    return input[0] &amp;&amp; input[1] &amp;&amp; !input[0].includes(input[1]);
                },
                text: 'text does not contain',
                appliesTo: ['string'],
                inputCount: 1,
                getDescription: function (values) {
                    return ' does not contain ' + values[0];
                }
            },
            textStartsWith: {
                operation: function (input) {
                    return input[0].startsWith(input[1]);
                },
                text: 'text starts with',
                appliesTo: ['string'],
                inputCount: 1,
                getDescription: function (values) {
                    return ' starts with ' + values[0];
                }
            },
            textEndsWith: {
                operation: function (input) {
                    return input[0].endsWith(input[1]);
                },
                text: 'text ends with',
                appliesTo: ['string'],
                inputCount: 1,
                getDescription: function (values) {
                    return ' ends with ' + values[0];
                }
            },
            textIsExactly: {
                operation: function (input) {
                    return input[0] === input[1];
                },
                text: 'text is exactly',
                appliesTo: ['string'],
                inputCount: 1,
                getDescription: function (values) {
                    return ' is exactly ' + values[0];
                }
            },
            isUndefined: {
                operation: function (input) {
                    return typeof input[0] === 'undefined';
                },
                text: 'is undefined',
                appliesTo: ['string', 'number'],
                inputCount: 0,
                getDescription: function () {
                    return ' is undefined';
                }
            },
            isDefined: {
                operation: function (input) {
                    return typeof input[0] !== 'undefined';
                },
                text: 'is defined',
                appliesTo: ['string', 'number'],
                inputCount: 0,
                getDescription: function () {
                    return ' is defined';
                }
            }
        };
    }

    /**
     * Evaluate the conditions passed in as an argument, and return the boolean
     * value of these conditions. Available evaluation modes are 'any', which will
     * return true if any of the conditions evaluates to true (i.e. logical OR); 'all',
     * which returns true only if all conditions evalute to true (i.e. logical AND);
     * or 'js', which returns the boolean value of a custom JavaScript conditional.
     * @param {} conditions Either an array of objects with object, key, operation,
     *                      and value fields, or a string representing a JavaScript
     *                      condition.
     * @param {string} mode The key of the mode to use when evaluating the conditions.
     * @return {boolean} The boolean value of the conditions
     */
    ConditionEvaluator.prototype.execute = function (conditions, mode) {
        var active = false,
            conditionValue,
            conditionDefined = false,
            self = this,
            firstRuleEvaluated = false,
            compositionObjs = this.compositionObjs;

        if (mode === 'js') {
            active = this.executeJavaScriptCondition(conditions);
        } else {
            (conditions || []).forEach(function (condition) {
                conditionDefined = false;
                if (condition.object === 'any') {
                    conditionValue = false;
                    Object.keys(compositionObjs).forEach(function (objId) {
                        try {
                            conditionValue = conditionValue ||
                                self.executeCondition(objId, condition.key,
                                    condition.operation, condition.values);
                            conditionDefined = true;
                        } catch (e) {
                            //ignore a malformed condition
                        }
                    });
                } else if (condition.object === 'all') {
                    conditionValue = true;
                    Object.keys(compositionObjs).forEach(function (objId) {
                        try {
                            conditionValue = conditionValue &amp;&amp;
                                self.executeCondition(objId, condition.key,
                                    condition.operation, condition.values);
                            conditionDefined = true;
                        } catch (e) {
                            //ignore a malformed condition
                        }
                    });
                } else {
                    try {
                        conditionValue = self.executeCondition(condition.object, condition.key,
                            condition.operation, condition.values);
                        conditionDefined = true;
                    } catch (e) {
                        //ignore malformed condition
                    }
                }

                if (conditionDefined) {
                    active = (mode === 'all' &amp;&amp; !firstRuleEvaluated ? true : active);
                    firstRuleEvaluated = true;
                    if (mode === 'any') {
                        active = active || conditionValue;
                    } else if (mode === 'all') {
                        active = active &amp;&amp; conditionValue;
                    }
                }
            });
        }
        return active;
    };

    /**
     * Execute a condition defined as an object.
     * @param {string} object The identifier of the telemetry object to retrieve data from
     * @param {string} key The property of the telemetry object
     * @param {string} operation The key of the operation in this ConditionEvaluator to executeCondition
     * @param {string} values An array of comparison values to invoke the operation with
     * @return {boolean} The value of this condition
     */
    ConditionEvaluator.prototype.executeCondition = function (object, key, operation, values) {
        var cache = (this.useTestCache ? this.testCache : this.subscriptionCache),
            telemetryValue,
            op,
            input,
            validator;

        if (cache[object] &amp;&amp; typeof cache[object][key] !== 'undefined') {
            telemetryValue = [cache[object][key]];
        }
        op = this.operations[operation] &amp;&amp; this.operations[operation].operation;
        input = telemetryValue &amp;&amp; telemetryValue.concat(values);
        validator = op &amp;&amp; this.inputValidators[this.operations[operation].appliesTo[0]];
        if (op &amp;&amp; input &amp;&amp; validator) {
            if (this.operations[operation].appliesTo.length === 2) {
                return (this.validateNumberInput(input) || this.validateStringInput(input)) &amp;&amp; op(input);
            } else {
                return validator(input) &amp;&amp; op(input);
            }
        } else {
            throw new Error('Malformed condition');
        }
    };

    /**
     * A function that returns true only if each value in its input argument is
     * of a numerical type
     * @param {[]} input An array of values
     * @returns {boolean}
     */
    ConditionEvaluator.prototype.validateNumberInput = function (input) {
        var valid = true;
        input.forEach(function (value) {
            valid = valid &amp;&amp; (typeof value === 'number');
        });
        return valid;
    };

    /**
     * A function that returns true only if each value in its input argument is
     * a string
     * @param {[]} input An array of values
     * @returns {boolean}
     */
    ConditionEvaluator.prototype.validateStringInput = function (input) {
        var valid = true;
        input.forEach(function (value) {
            valid = valid &amp;&amp; (typeof value === 'string');
        });
        return valid;
    };

    /**
     * Get the keys of operations supported by this evaluator
     * @return {string[]} An array of the keys of supported operations
     */
    ConditionEvaluator.prototype.getOperationKeys = function () {
        return Object.keys(this.operations);
    };

    /**
     * Get the human-readable text corresponding to a given operation
     * @param {string} key The key of the operation
     * @return {string} The text description of the operation
     */
    ConditionEvaluator.prototype.getOperationText = function (key) {
        return this.operations[key].text;
    };

    /**
     * Returns true only of the given operation applies to a given type
     * @param {string} key The key of the operation
     * @param {string} type The value type to query
     * @returns {boolean} True if the condition applies, false otherwise
     */
    ConditionEvaluator.prototype.operationAppliesTo = function (key, type) {
        return (this.operations[key].appliesTo.includes(type));
    };

    /**
     * Return the number of value inputs required by an operation
     * @param {string} key The key of the operation to query
     * @return {number}
     */
    ConditionEvaluator.prototype.getInputCount = function (key) {
        if (this.operations[key]) {
            return this.operations[key].inputCount;
        }
    };

    /**
     * Return the human-readable shorthand description of the operation for a rule header
     * @param {string} key The key of the operation to query
     * @param {} values An array of values with which to invoke the getDescription function
     *                  of the operation
     * @return {string} A text description of this operation
     */
    ConditionEvaluator.prototype.getOperationDescription = function (key, values) {
        if (this.operations[key]) {
            return this.operations[key].getDescription(values);
        }
    };

    /**
     * Return the HTML input type associated with a given operation
     * @param {string} key The key of the operation to query
     * @return {string} The key for an HTML5 input type
     */
    ConditionEvaluator.prototype.getInputType = function (key) {
        var type;
        if (this.operations[key]) {
            type = this.operations[key].appliesTo[0];
        }
        if (this.inputTypes[type]) {
            return this.inputTypes[type];
        }
    };

    /**
     * Returns the HTML input type associated with a value type
     * @param {string} dataType The JavaScript value type
     * @return {string} The key for an HTML5 input type
     */
    ConditionEvaluator.prototype.getInputTypeById = function (dataType) {
        return this.inputTypes[dataType];
    };

    /**
     * Set the test data cache used by this rule evaluator
     * @param {object} testCache A mock cache following the format of the real
     *                           subscription cache
     */
    ConditionEvaluator.prototype.setTestDataCache = function (testCache) {
        this.testCache = testCache;
    };

    /**
     * Have this RuleEvaluator pull data values from the provided test cache
     * instead of its actual subscription cache when evaluating. If invoked with true,
     * will use the test cache; otherwise, will use the subscription cache
     * @param {boolean} useTestData Boolean flag
     */
    ConditionEvaluator.prototype.useTestData = function (useTestCache) {
        this.useTestCache = useTestCache;
    };

    return ConditionEvaluator;
});
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="module-openmct.Dialog.html">Dialog</a></li><li><a href="module-openmct.MCT.html">MCT</a></li><li><a href="module-openmct.Type.html">Type</a></li><li><a href="platform_commonUI_formats.LocalTimeFormat.html">LocalTimeFormat</a></li><li><a href="platform_commonUI_regions.InspectorRegion.html">InspectorRegion</a></li><li><a href="platform_commonUI_regions.Region.html">Region</a></li><li><a href="platform_features_plot.PlotViewPolicy.html">PlotViewPolicy</a></li></ul><h3>Events</h3><ul><li><a href="module-openmct.MCT.html#~event:start">start</a></li><li><a href="module-openmct.TimeAPI.html#~event:bounds">bounds</a></li><li><a href="module-openmct.TimeAPI.html#~event:clock">clock</a></li><li><a href="module-openmct.TimeAPI.html#~event:clockOffsets">clockOffsets</a></li><li><a href="module-openmct.TimeAPI.html#~event:timeOfInterest">timeOfInterest</a></li><li><a href="module-openmct.TimeAPI.html#~event:timeSystem">timeSystem</a></li></ul><h3>Interfaces</h3><ul><li><a href="module-openmct.CompositionAPI.html">CompositionAPI</a></li><li><a href="module-openmct.CompositionCollection.html">CompositionCollection</a></li><li><a href="module-openmct.CompositionProvider.html">CompositionProvider</a></li><li><a href="module-openmct.GestureAPI.html">GestureAPI</a></li><li><a href="module-openmct.InspectorViewProvider.html">InspectorViewProvider</a></li><li><a href="module-openmct.InspectorViewRegistry.html">InspectorViewRegistry</a></li><li><a href="module-openmct.ObjectAPI.html">ObjectAPI</a></li><li><a href="module-openmct.ObjectProvider.html">ObjectProvider</a></li><li><a href="module-openmct.TelemetryAPI.html">TelemetryAPI</a></li><li><a href="module-openmct.TelemetryAPI-LimitEvaluator.html">LimitEvaluator</a></li><li><a href="module-openmct.TelemetryAPI-TelemetryFormatter.html">TelemetryFormatter</a></li><li><a href="module-openmct.TelemetryAPI-TelemetryProvider.html">TelemetryProvider</a></li><li><a href="module-openmct.TimeAPI.html">TimeAPI</a></li><li><a href="module-openmct.ToolbarProvider.html">ToolbarProvider</a></li><li><a href="module-openmct.ToolbarRegistry.html">ToolbarRegistry</a></li><li><a href="module-openmct.TypeRegistry.html">TypeRegistry</a></li><li><a href="module-openmct.View.html">View</a></li><li><a href="module-openmct.ViewProvider.html">ViewProvider</a></li><li><a href="module-openmct.ViewRegistry.html">ViewRegistry</a></li><li><a href="MutableObject.html">MutableObject</a></li></ul><h3>Global</h3><ul><li><a href="global.html#defaults">defaults</a></li><li><a href="global.html#fetch">fetch</a></li><li><a href="global.html#getDrawAPI">getDrawAPI</a></li><li><a href="global.html#getFallbackDrawAPI">getFallbackDrawAPI</a></li><li><a href="global.html#getPersistedSeriesConfig">getPersistedSeriesConfig</a></li><li><a href="global.html#initialize">initialize</a></li><li><a href="global.html#nearestPoint">nearestPoint</a></li><li><a href="global.html#onDestroy">onDestroy</a></li><li><a href="global.html#onXKeyChange">onXKeyChange</a></li><li><a href="global.html#onYKeyChange">onYKeyChange</a></li><li><a href="global.html#purgeRecordsOutsideRange">purgeRecordsOutsideRange</a></li><li><a href="global.html#reset">reset</a></li><li><a href="global.html#resetStats">resetStats</a></li><li><a href="global.html#setColor">setColor</a></li><li><a href="global.html#updateDomainObject">updateDomainObject</a></li><li><a href="global.html#updateFromSeries">updateFromSeries</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Fri Jul 20 2018 22:50:59 GMT+0000 (UTC)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
